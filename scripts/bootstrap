#!/usr/bin/env bash

SOURCE="${BASH_SOURCE[0]}"
while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
  DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
  SOURCE="$(readlink "$SOURCE")"
  [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
done
DIR="$( cd -P "$( dirname "$SOURCE" )" && pwd )"
REPOROOT="$( cd -P "$DIR/.." && pwd )"

echo "Bootstrapping dotnet.exe using DNX"

if [ -z "$RID" ]; then
    UNAME=$(uname)
    if [ "$UNAME" == "Darwin" ]; then
        RID=osx.10.10-x64
    elif [ "$UNAME" == "Linux" ]; then
        # Detect Distro?
        RID=ubuntu.14.04-x64
    else
        echo "Unknown OS: $UNAME" 1>&2
        exit 1
    fi
fi

OUTPUT_ROOT=$REPOROOT/artifacts/$RID
STAGE1_DIR=$OUTPUT_ROOT/stage1
STAGE2_DIR=$OUTPUT_ROOT/stage2

echo "Cleaning artifacts folder"
rm -rf $OUTPUT_ROOT

export DOTNET_CLR_HOSTS_PATH=$REPOROOT/ext/CLRHost/$RID

if ! type dnvm > /dev/null 2>&1; then
    curl -sSL https://raw.githubusercontent.com/aspnet/Home/dev/dnvminstall.sh | DNX_BRANCH=dev sh && source ~/.dnx/dnvm/dnvm.sh
fi

echo "Installing and use-ing the latest CoreCLR x64 DNX ..."
dnvm install latest -u -r coreclr -alias dotnet_bootstrap
rc=$?; if [[ $rc != 0 ]]; then exit $rc; fi

dnvm use dotnet_bootstrap -r coreclr -arch x64
rc=$?; if [[ $rc != 0 ]]; then exit $rc; fi

type -p dnu >/dev/null
if [ ! $? ]; then
    echo "DNU is required to restore" 1>&2
    exit 1
fi

echo "Running 'dnu restore' to restore packages for DNX-hosted projects"

dnu restore "$REPOROOT" --runtime osx.10.10-x64 --runtime ubuntu.14.04-x64 --runtime osx.10.11-x64

echo "Downloading LKG for bootstrap"

BOOTSTRAP_NAME="dotnet-cli-bootstrap.$UNAME.1"
PACKAGE_NAME="$BOOTSTRAP_NAME.zip"

if [ -d $REPOROOT/$BOOTSTRAP_NAME ]; then
    echo "Already installed"
else
    rm $REPOROOT/$PACKAGE_NAME 2>/dev/null
    pushd $REPOROOT
    curl -O https://dotnetci.blob.core.windows.net/dotnet-cli/$PACKAGE_NAME
    unzip -uoq $PACKAGE_NAME
    popd
fi

BOOTSTRAP_PUBLISH=$REPOROOT/$BOOTSTRAP_NAME/dotnet-publish

# Clean up stage1
[ -d "$STAGE1_DIR" ] && rm -Rf "$STAGE1_DIR"

echo "Building basic dotnet tools using bootstrap LKG $PACKAGE_NAME"
$BOOTSTRAP_PUBLISH --framework dnxcore50 --runtime $RID --output "$STAGE1_DIR" "$REPOROOT/src/Microsoft.DotNet.Cli"
rc=$?; if [[ $rc != 0 ]]; then exit $rc; fi
$BOOTSTRAP_PUBLISH --framework dnxcore50 --runtime $RID --output "$STAGE1_DIR" "$REPOROOT/src/Microsoft.DotNet.Tools.Compiler"
rc=$?; if [[ $rc != 0 ]]; then exit $rc; fi
$BOOTSTRAP_PUBLISH --framework dnxcore50 --runtime $RID --output "$STAGE1_DIR" "$REPOROOT/src/Microsoft.DotNet.Tools.Compiler.Csc"
rc=$?; if [[ $rc != 0 ]]; then exit $rc; fi
$BOOTSTRAP_PUBLISH --framework dnxcore50 --runtime $RID --output "$STAGE1_DIR" "$REPOROOT/src/Microsoft.DotNet.Tools.Publish"
rc=$?; if [[ $rc != 0 ]]; then exit $rc; fi
$BOOTSTRAP_PUBLISH --framework dnxcore50 --runtime $RID --output "$STAGE1_DIR" "$REPOROOT/src/Microsoft.DotNet.Tools.Resgen"

# Add stage1 to the path and use it to build stage2
export PATH=$STAGE1_DIR:$PATH

echo "Building stage2 dotnet using stage1 ..."
dotnet publish --framework dnxcore50 --runtime $RID --output "$STAGE2_DIR" "$REPOROOT/src/Microsoft.DotNet.Cli"
rc=$?; if [[ $rc != 0 ]]; then exit $rc; fi
dotnet publish --framework dnxcore50 --runtime $RID --output "$STAGE2_DIR" "$REPOROOT/src/Microsoft.DotNet.Tools.Compiler"
rc=$?; if [[ $rc != 0 ]]; then exit $rc; fi
dotnet publish --framework dnxcore50 --runtime $RID --output "$STAGE2_DIR" "$REPOROOT/src/Microsoft.DotNet.Tools.Compiler.Csc"
rc=$?; if [[ $rc != 0 ]]; then exit $rc; fi
dotnet publish --framework dnxcore50 --runtime $RID --output "$STAGE2_DIR" "$REPOROOT/src/Microsoft.DotNet.Tools.Publish"
rc=$?; if [[ $rc != 0 ]]; then exit $rc; fi
dotnet publish --framework dnxcore50 --runtime $RID --output "$STAGE2_DIR" "$REPOROOT/src/Microsoft.DotNet.Tools.Resgen"
rc=$?; if [[ $rc != 0 ]]; then exit $rc; fi
